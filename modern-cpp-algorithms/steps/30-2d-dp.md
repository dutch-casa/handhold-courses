---
title: 2D DP and Grid Problems
---

# 2D table setup

{{show: grid-viz grow 0.5s spring}} 2D DP extends the 1D pattern to two dimensions. The state is dp[i][j] — typically "the answer considering the first i rows and j columns" or "the answer at cell (i, j)".

{{focus: state-space}} {{annotate: state-space "State space"}} The table has dimensions that match your problem's two axes. For grid problems that's rows × cols. For string problems it's len(s1) × len(s2). Define what dp[i][j] represents before writing a single line of code.

{{focus: dependencies}} {{annotate: dependencies "Fill order"}} Dependencies determine fill order. If dp[i][j] depends on dp[i-1][j] and dp[i][j-1], fill top-to-bottom, left-to-right. Every value you read must already be computed. Draw the dependency arrows first.

{{focus: base-row}} {{annotate: base-row "First row/col"}} The first row and first column are often base cases. Handle them separately in initialization before the main fill loop. Getting these wrong silently corrupts the entire table.

{{focus: none}} State definition → dependency graph → base cases → fill loop. The 2D template is identical to 1D, just in two dimensions.

```data:grid-viz type=matrix
[[0,0,0,0,0],[0,"dp[1][1]","dp[1][2]","dp[1][3]",0],[0,"dp[2][1]","dp[2][2]","dp[2][3]",0],[0,"dp[3][1]","dp[3][2]","dp[3][3]",0]]
---
state-space: dp[2][2]
dependencies: dp[2][2]
base-row: 0
```

# Unique paths

{{clear: slide}}

{{show: paths-code typewriter 1.5s linear}} Unique paths: m × n grid, start at top-left, reach bottom-right. Only move right or down. How many distinct paths exist?

{{focus: state}} {{zoom: 1.2x}} {{annotate: state "dp[i][j] = paths to (i,j)"}} dp[i][j] is the number of unique paths to reach cell (i, j). You can only arrive from above or from the left — so dp[i][j] = dp[i-1][j] + dp[i][j-1].

{{zoom: 1x}} {{focus: base-case}} {{zoom: 1.2x}} {{annotate: base-case "Edges = 1 path"}} The first row and first column each have exactly one path — you can only move right along the top row, and only move down along the left column. Initialize them to 1.

{{zoom: 1x}} {{focus: fill}} {{zoom: 1.2x}} {{annotate: fill "Sum two neighbors"}} Fill top-left to bottom-right. Each interior cell sums its top neighbor and left neighbor. Clean, no edge cases after initialization.

{{zoom: 1x}} {{focus: none}} This is one of the cleanest 2D DP problems. The dependency structure is a DAG that naturally flows top-left to bottom-right.

```code:paths-code lang=cpp
// dp[i][j] = unique paths to reach cell (i, j)
int uniquePaths(int m, int n) {
    std::vector<std::vector<int>> dp(m, std::vector<int>(n, 0));

    // Base cases: first row and first column are all 1
    for (int i = 0; i < m; ++i) dp[i][0] = 1;
    for (int j = 0; j < n; ++j) dp[0][j] = 1;

    // Fill top-left to bottom-right
    for (int i = 1; i < m; ++i) {
        for (int j = 1; j < n; ++j) {
            dp[i][j] = dp[i-1][j] + dp[i][j-1];
        }
    }
    return dp[m-1][n-1];
}
---
state: 2
base-case: 5-6
fill: 9-13
```

# Min path sum

{{clear: slide}}

{{show: minpath-code typewriter 1.5s linear}} Min path sum: same grid, each cell has a cost. Find the path from top-left to bottom-right with minimum total cost. Move only right or down.

{{focus: state}} {{zoom: 1.2x}} {{annotate: state "dp[i][j] = min cost to (i,j)"}} dp[i][j] is the minimum cost to reach (i, j). The recurrence is dp[i][j] = grid[i][j] + min(dp[i-1][j], dp[i][j-1]). Add the current cell's cost to the cheaper of the two ways to arrive.

{{zoom: 1x}} {{focus: base-case}} {{zoom: 1.2x}} {{annotate: base-case "Prefix sums on edges"}} First row: cumulative sum left to right — only one way to travel. First column: cumulative sum top to bottom. No choice on the edges.

{{zoom: 1x}} {{focus: fill}} {{zoom: 1.3x}} {{annotate: fill "Min of two arrivals"}} Interior cells take the minimum of the top and left neighbor, then add the cell's cost. The grid itself can serve as the DP table if mutation is acceptable — saves O(mn) space.

{{zoom: 1x}} {{focus: none}} Notice the pattern: grid problems that restrict movement to right/down always have the same fill order and similar base cases. Only the recurrence changes.

```code:minpath-code lang=cpp
// dp[i][j] = minimum cost path to cell (i, j)
int minPathSum(std::vector<std::vector<int>>& grid) {
    const int m = static_cast<int>(grid.size());
    const int n = static_cast<int>(grid[0].size());
    auto& dp = grid;  // reuse grid as DP table

    // Base cases
    for (int i = 1; i < m; ++i) dp[i][0] += dp[i-1][0];
    for (int j = 1; j < n; ++j) dp[0][j] += dp[0][j-1];

    // Fill
    for (int i = 1; i < m; ++i) {
        for (int j = 1; j < n; ++j) {
            dp[i][j] += std::min(dp[i-1][j], dp[i][j-1]);
        }
    }
    return dp[m-1][n-1];
}
---
state: 2
base-case: 7-8
fill: 11-15
```

# Longest common subsequence

{{clear: slide}}

{{show: lcs-code typewriter 2s linear}} LCS: given two strings, find the length of their longest common subsequence. Characters don't need to be contiguous — they just need to appear in order.

{{focus: state}} {{zoom: 1.2x}} {{annotate: state "dp[i][j] = LCS of first i,j chars"}} dp[i][j] is the LCS length of s1[0..i-1] and s2[0..j-1]. The 1-indexed offset makes base cases trivial — dp[0][j] and dp[i][0] are all zero (empty string LCS is 0).

{{zoom: 1x}} {{focus: match}} {{zoom: 1.3x}} {{annotate: match "Characters match"}} If s1[i-1] == s2[j-1], those characters are part of the LCS. dp[i][j] = dp[i-1][j-1] + 1. Extend the LCS from the diagonal.

{{zoom: 1x}} {{focus: no-match}} {{zoom: 1.2x}} {{annotate: no-match "Characters differ"}} If they don't match, the LCS comes from either excluding the current character of s1 or s2. dp[i][j] = max(dp[i-1][j], dp[i][j-1]).

{{zoom: 1x}} {{focus: none}} LCS is the foundation for diff tools, spell checkers, and DNA sequence alignment. The recurrence is the key — match extends the diagonal, mismatch takes the max of the sides.

```code:lcs-code lang=cpp
// dp[i][j] = LCS length of s1[0..i-1] and s2[0..j-1]
int lcs(const std::string& s1, const std::string& s2) {
    const int m = static_cast<int>(s1.size());
    const int n = static_cast<int>(s2.size());
    std::vector<std::vector<int>> dp(m + 1, std::vector<int>(n + 1, 0));

    // dp[0][*] = dp[*][0] = 0 (already initialized)

    for (int i = 1; i <= m; ++i) {
        for (int j = 1; j <= n; ++j) {
            if (s1[i-1] == s2[j-1]) {
                dp[i][j] = dp[i-1][j-1] + 1;   // match: extend diagonal
            } else {
                dp[i][j] = std::max(dp[i-1][j], dp[i][j-1]);  // skip one
            }
        }
    }
    return dp[m][n];
}
---
state: 2
match: 11-12
no-match: 14
```

# Edit distance

{{clear: slide}}

{{show: edit-code typewriter 2s linear}} Edit distance: minimum insertions, deletions, and substitutions to transform string s1 into string s2. The Levenshtein distance.

{{focus: state}} {{zoom: 1.2x}} {{annotate: state "dp[i][j] = edits for prefixes"}} dp[i][j] is the minimum edits to transform s1[0..i-1] into s2[0..j-1]. Base cases: dp[i][0] = i (delete all i characters), dp[0][j] = j (insert all j characters).

{{zoom: 1x}} {{focus: match}} {{zoom: 1.2x}} {{annotate: match "Free if equal"}} If s1[i-1] == s2[j-1], no edit needed. dp[i][j] = dp[i-1][j-1]. Copy the diagonal for free.

{{zoom: 1x}} {{focus: three-ops}} {{zoom: 1.3x}} {{annotate: three-ops "Three operations"}} If they differ, take the minimum of three options. dp[i-1][j] + 1 is delete from s1. dp[i][j-1] + 1 is insert into s1. dp[i-1][j-1] + 1 is substitute. All cost one operation.

{{zoom: 1x}} {{focus: none}} Remember the three cases by their position in the table. Diagonal = substitute. Left = insert. Top = delete. Three neighbors, three operations, take the minimum plus one.

```code:edit-code lang=cpp
// dp[i][j] = min edits to transform s1[0..i-1] → s2[0..j-1]
int editDistance(const std::string& s1, const std::string& s2) {
    const int m = static_cast<int>(s1.size());
    const int n = static_cast<int>(s2.size());
    std::vector<std::vector<int>> dp(m + 1, std::vector<int>(n + 1, 0));

    // Base cases
    for (int i = 0; i <= m; ++i) dp[i][0] = i;  // delete all
    for (int j = 0; j <= n; ++j) dp[0][j] = j;  // insert all

    for (int i = 1; i <= m; ++i) {
        for (int j = 1; j <= n; ++j) {
            if (s1[i-1] == s2[j-1]) {
                dp[i][j] = dp[i-1][j-1];              // no cost
            } else {
                dp[i][j] = 1 + std::min({
                    dp[i-1][j-1],  // substitute
                    dp[i-1][j],    // delete
                    dp[i][j-1]     // insert
                });
            }
        }
    }
    return dp[m][n];
}
---
state: 2
match: 13-14
three-ops: 16-20
```

# Space optimization — rolling arrays

{{clear: slide}}

{{show: rolling-code typewriter 2s linear}} Most 2D DP tables only look at the current row and the previous row. That means you can cut space from O(mn) to O(n) with a rolling array.

{{focus: insight}} {{zoom: 1.2x}} {{annotate: insight "Only need prev row"}} In LCS, dp[i][j] depends only on dp[i-1][j-1], dp[i-1][j], and dp[i][j-1]. Everything from rows before i-1 is irrelevant. Two rows suffice.

{{zoom: 1x}} {{focus: two-rows}} {{zoom: 1.3x}} {{annotate: two-rows "Ping-pong buffers"}} Keep two rows: prev and curr. After filling curr, swap them. Now prev holds what was curr, ready for the next iteration.

{{zoom: 1x}} {{focus: one-row}} {{zoom: 1.3x}} {{annotate: one-row "Single row with diagonal"}} For problems where dp[i][j] only needs dp[i-1][j] and dp[i][j-1] — but not dp[i-1][j-1] — you can use a single row. Update right to left to avoid overwriting values you still need.

{{zoom: 1x}} {{focus: none}} Rolling arrays are a standard optimization. Always verify which cells the recurrence touches before collapsing dimensions.

```code:rolling-code lang=cpp
// LCS with O(n) space using two rows
int lcs_optimized(const std::string& s1, const std::string& s2) {
    const int m = static_cast<int>(s1.size());
    const int n = static_cast<int>(s2.size());

    std::vector<int> prev(n + 1, 0), curr(n + 1, 0);

    for (int i = 1; i <= m; ++i) {
        for (int j = 1; j <= n; ++j) {
            if (s1[i-1] == s2[j-1]) {
                curr[j] = prev[j-1] + 1;
            } else {
                curr[j] = std::max(prev[j], curr[j-1]);
            }
        }
        std::swap(prev, curr);
        std::ranges::fill(curr, 0);
    }
    return prev[n];
}
---
insight: 2
two-rows: 6
one-row: 8-15
```

# Matrix chain multiplication

{{clear: slide}}

{{show: mcm-code typewriter 2s linear}} Matrix chain multiplication: given n matrices, find the minimum number of scalar multiplications to compute their product. The order of parenthesization matters enormously.

{{focus: state}} {{zoom: 1.2x}} {{annotate: state "dp[i][j] = min cost for i..j"}} dp[i][j] is the minimum multiplications to compute the product of matrices i through j. This is interval DP — the state is a range, not a prefix.

{{zoom: 1x}} {{focus: fill-order}} {{zoom: 1.2x}} {{annotate: fill-order "Length-first fill"}} Fill by increasing interval length. Length 1 is trivial (single matrix, zero cost). Length 2, then 3, and so on. Never compute dp[i][j] before all shorter subproblems are solved.

{{zoom: 1x}} {{focus: recurrence}} {{zoom: 1.3x}} {{annotate: recurrence "Split point k"}} For each interval [i, j], try every split point k. The cost is dp[i][k] + dp[k+1][j] + dims[i] * dims[k+1] * dims[j+1]. That last term is the cost of multiplying the two resulting matrices together.

{{zoom: 1x}} {{focus: none}} Interval DP appears in many problems: burst balloons, palindrome partitioning, optimal BST. The fill-by-length trick is universal.

```code:mcm-code lang=cpp
// dims[i] = rows of matrix i, dims[i+1] = cols of matrix i
// dp[i][j] = min multiplications to compute product i..j
int matrixChain(const std::vector<int>& dims) {
    const int n = static_cast<int>(dims.size()) - 1;  // n matrices
    std::vector<std::vector<int>> dp(n, std::vector<int>(n, 0));

    // Fill by increasing interval length
    for (int len = 2; len <= n; ++len) {
        for (int i = 0; i <= n - len; ++i) {
            const int j = i + len - 1;
            dp[i][j] = std::numeric_limits<int>::max();

            // Try every split point k
            for (int k = i; k < j; ++k) {
                int cost = dp[i][k] + dp[k+1][j]
                         + dims[i] * dims[k+1] * dims[j+1];
                dp[i][j] = std::min(dp[i][j], cost);
            }
        }
    }
    return dp[0][n-1];
}
---
state: 2
fill-order: 8-9
recurrence: 13-17
```
